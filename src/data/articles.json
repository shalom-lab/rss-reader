{
  "categories": [
    {
      "id": "技术博客",
      "name": "技术博客",
      "color": "blue"
    },
    {
      "id": "R语言",
      "name": "R语言",
      "color": "green"
    },
    {
      "id": "Python",
      "name": "Python",
      "color": "red"
    }
  ],
  "articles": [
    {
      "id": "https://realpython.com/podcasts/rpp/242/",
      "title": "The Real Python Podcast – Episode #242: Eric Matthes: Maybe Don't Start With Unit Tests",
      "description": "Should you always start testing your code with unit tests? When does it make sense to look at integration or end-to-end testing as a first step instead? This week on the show, we speak with previous guest Eric Matthes about where to begin testing your code.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/242/",
      "pubDate": "2025-03-07T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-bytes/",
      "title": "Bytes Objects: Handling Binary Data in Python",
      "description": "The bytes data type is an immutable sequence of unsigned bytes used for handling binary data in Python. You can create a bytes object using the literal syntax, the bytes() function, or the bytes.fromhex() method. Since bytes are closely related to strings, you often convert between the two data types, applying the correct character encoding.\nBy the end of this tutorial, you’ll understand that:\nPython bytes objects are immutable sequences of unsigned bytes used for handling binary data.\nThe difference between bytes and bytearray is that bytes objects are read-only, while bytearray objects are mutable.\nYou convert a Python string to bytes using the str.encode() method, the bytes() function, or the codecs module.\nEndianness refers to the byte order used to represent binary data in memory, which can be either little-endian or big-endian.\nThis tutorial starts with a brief overview of binary data fundamentals, setting the scene for the remaining part, which delves into creating and manipulating bytes objects in Python. Along the way, it touches on related topics, such as bytearray, bytes-like objects, and the buffer protocol. To top it off, you’ll find several real-life examples and exercises at the end, which demonstrate the concepts discussed.\nTo get the most out of this tutorial, you should be familiar with Python basics, particularly built-in data types.\nGet Your Code: Click here to download the free sample code that you’ll use to learn about bytes objects and handling binary data in Python.\n Take the Quiz: Test your knowledge with our interactive “Python Bytes” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nPython Bytes \n      \nIn this quiz, you'll test your understanding of Python bytes objects. By working through this quiz, you'll revisit the key concepts related to this low-level data type.\nBrushing Up on Binary Fundamentals\nIf you’re new to binary data or need a quick refresher, then consider sticking around. This section will provide a brief overview of binary representations, emphasizing a Python programmer’s perspective. On the other hand, if you’re already comfortable with the basics, then feel free to dive right into creating bytes objects in Python.\nBits, Bytes, and Binary Data\nVirtually every piece of information, from books and music to movies, can be stored as binary data in a computer’s memory. The word binary implies that the information is stored as a sequence of binary digits, or bits for short. Each bit can hold a value of either one or zero, which is particularly well-suited for storage in electronic devices since they often use distinct voltage levels to represent these binary states.\nFor example, the binary sequence below may represent the color of a pixel in an image:\n \n\n\n\n\n1 1 0 0 0 0 1 0 0 0 1 1 0 0 1 1 0 0 1 0 0 1\n\n\n\n\nTo make the interpretation of such binary sequences more systematic, you often arrange the individual bits into uniform groups. The standard unit of information in modern computing consists of exactly eight bits, which is why it’s sometimes known as an octet, although most people call it a byte. A single 8-bit byte allows for 256 possible bit combinations (28).\nWith this in mind, you can break up the bit sequence above into these three bytes:\n \n \n \n\n\n\n\n0 0 1 1 0 0 0 0\n1 0 0 0 1 1 0 0\n1 1 0 0 1 0 0 1\n\n\n\n\nNotice that the leftmost byte has been padded with two leading zeros to ensure a consistent number of bits across all bytes. Together, they form a 24-bit color depth, letting you choose from more than 16 million (224) unique colors per pixel.\nIn this case, each byte corresponds to one of three primary colors (red, green, and blue) within the RGB color model, effectively serving as coordinates in the RGB color space. Changing their proportions can be loosely compared to mixing paints to achieve a desired hue.\nNote: Strictly speaking, the RGB color model is an additive one, meaning it combines specific wavelengths of light to synthesize complex colors. In contrast, paint mixing follows a subtractive model, where pigments absorb certain wavelengths of light from the visible spectrum.\nTo reveal the pixel’s primary colors as decimal numbers, you can open the Python REPL and define binary literals by prefixing the corresponding bit sequences with 0b:\nPython\n    \n    \n\n      \n    \n>>> 0b00110000, 0b10001100, 0b11001001\n(48, 140, 201)\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nBinary literals are an alternative way of defining integers in Python. Other types of numeric literals include hexadecimal and octal. For example, you can represent the integer 48 as 0x30 in hexadecimal or 0o60 in octal, allowing you to write the same number differently.\nHaving such flexibility comes in handy since it’s customary to express byte values using the hexadecimal numeral system. By rewriting each byte as a two-digit hex number, you can represent your pixel color much more compactly compared to the equivalent binary sequence:\nPython\n    \n    \n\n      \n    \n>>> hex(48), hex(140), hex(201)\n('0x30', '0x8c', '0xc9')\n\n>>> int(\"308cc9\", base=16)\n3181769\n\n>>> int(\"001100001000110011001001\", base=2)\n3181769\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nCalling the built-in hex() function on an integer returns the corresponding hexadecimal literal as a string. When you combine the resulting hex numbers, you’re able to describe a 24-bit color with just six digits (308cc9). Go ahead and open an online color picker to see what that encoded value looks like:\nRead the full article at https://realpython.com/python-bytes/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-bytes/",
      "pubDate": "2025-03-05T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/working-with-python-polars/",
      "title": "Working With Python Polars",
      "description": "In the world of data analysis and manipulation, Python has long been the go-to language. With extensive and user-friendly libraries like NumPy, pandas, and PySpark, there’s a solution available for almost any data-driven task. Among these libraries, one name that’s been generating a significant amount of buzz lately is Polars.\nPolars is a high-performance DataFrame library, designed to provide fast and efficient data processing capabilities. Inspired by the reigning pandas library, Polars takes things to another level, offering a seamless experience for working with large datasets that might not fit into memory.\nIn this video course, you’ll learn:\nWhy Polars is so performant and attention-grabbing\nHow to work with DataFrames, expressions, and contexts\nHow to read data into DataFrames\nHow to group and aggregate data \nWhat the lazy API is and how to build lazy queries\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/working-with-python-polars/",
      "pubDate": "2025-03-04T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-while-loop/",
      "title": "Python while Loops: Repeating Tasks Conditionally",
      "description": "Python’s while loop enables you to execute a block of code repeatedly as long as a given condition remains true. Unlike for loops, which iterate a known number of times, while loops are ideal for situations where the number of iterations isn’t known upfront.\nLoops are a pretty useful construct in Python, so learning how to write and use them is a great skill for you as a Python developer.\nBy the end of this tutorial, you’ll understand that:\nwhile is a Python keyword used to initiate a loop that repeats a block of code as long as a condition is true.\nA while loop works by evaluating a condition at the start of each iteration. If the condition is true, then the loop executes. Otherwise, it terminates.\nwhile loops are useful when the number of iterations is unknown, such as waiting for a condition to change or continuously processing user input.\nwhile True in Python creates an infinite loop that continues until a break statement or external interruption occurs.\nPython lacks a built-in do-while loop, but you can emulate it using a while True loop with a break statement for conditional termination.\nWith this knowledge, you’re prepared to write effective while loops in your Python programs, handling a wide range of iteration needs.\nGet Your Code: Click here to download the free sample code that shows you how to work with while loops in Python.\n Take the Quiz: Test your knowledge with our interactive “Python while Loops: Repeating Tasks Conditionally” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nPython while Loops: Repeating Tasks Conditionally \n      \nIn this quiz, you'll test your understanding of Python's while loop. This loop allows you to execute a block of code repeatedly as long as a given condition remains true. Understanding how to use while loops effectively is a crucial skill for any Python developer.\nGetting Started With Python while Loops\nIn programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\nfor loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\nwhile loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition.\nPython has both of these loops and in this tutorial, you’ll learn about while loops. In Python, you’ll generally use while loops when you need to repeat a series of tasks an unknown number of times.\nPython while loops are compound statements with a header and a code block that runs until a given condition becomes false. The basic syntax of a while loop is shown below:\nPython Syntax\n    \n    \nwhile condition:\n    <body>\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this syntax, condition is an expression that the loop evaluates for its truth value. If the condition is true, then the loop body runs. Otherwise, the loop terminates. Note that the loop body can consist of one or more statements that must be indented properly.\nHere’s a more detailed breakdown of this syntax:\nwhile is the keyword that initiates the loop header.\ncondition is an expression evaluated for truthiness that defines the exit condition.\n<body> consists of one or more statements to execute in each iteration.\nHere’s a quick example of how you can use a while loop to iterate over a decreasing sequence of numbers:\nPython\n    \n    \n\n      \n    \n>>> number = 5\n\n>>> while number > 0:\n...     print(number)\n...     number -= 1\n...\n5\n4\n3\n2\n1\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this example, number > 0 is the loop condition. If this condition returns a false value, the loop terminates. The body consists of a call to print() that displays the value on the screen. Next, you decrease the value of number. This change will produce a different result when the loop evaluates the condition in the next iteration.\nThe loop runs while the condition remains true. When the condition turns false, the loop terminates, and the program execution proceeds to the first statement after the loop body. In this example, the loop terminates when number reaches a value less than or equal to 0.\nIf the loop condition doesn’t become false, then you have a potentially infinite loop. Consider the following loop, and keep your fingers near the Ctrl+C key combination to terminate its execution:\nPython\n    \n    \n\n      \n    \n>>> number = 5\n>>> while number != 0:\n...     print(number)\n...     number -= 1\n...\n5\n4\n3\n2\n1\n\n>>> number = 5\n>>> while number != 0:\n...     print(number)\n...     number -= 2\n...\n5\n3\n1\n-1\n-3\n-5\n-7\n-9\n-11\nTraceback (most recent call last):\n    ...\nKeyboardInterrupt\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this example, the loop condition is number != 0. This condition works when you decrease number by 1. However, if you decrease it by 2, the condition may never become false, resulting in a potentially infinite loop. In such cases, you can usually terminate the loop by pressing Ctrl+C, which raises a KeyboardInterrupt exception on most operating systems.\nNote that the while loop checks its condition first before anything else happens. If it’s false to start with, then the loop body will never run:\nPython\n    \n    \n\n      \n    \n>>> number = 0\n>>> while number > 0:\n...     print(number)\n...     number -= 1\n...\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nRead the full article at https://realpython.com/python-while-loop/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-while-loop/",
      "pubDate": "2025-03-03T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-gil/",
      "title": "Quiz: What Is the Python Global Interpreter Lock (GIL)?",
      "description": "In this quiz, you’ll test your understanding of the\nPython Global Interpreter Lock (GIL).\nThe GIL allows only one thread to hold the control of the Python interpreter. This has advantages, but can also be a performance bottleneck in CPU-bound and multi-threaded code.\nBy working through this quiz, you’ll revisit the impact of the GIL on the performance of your Python programs and how to mitigate it.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-gil/",
      "pubDate": "2025-03-03T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/241/",
      "title": "The Real Python Podcast – Episode #241: Deciphering Python Jargon & Compiling Python 1.0",
      "description": "How do you learn the terms commonly used when speaking about Python? How is the jargon similar to other programming languages? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/241/",
      "pubDate": "2025-02-28T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-bytes/",
      "title": "Quiz: Python Bytes",
      "description": "In this quiz, you’ll test your understanding of Bytes Objects: Handling Binary Data in Python. By working through this quiz, you’ll revisit the key concepts related to this low-level data type.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-bytes/",
      "pubDate": "2025-02-28T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-while-loop/",
      "title": "Quiz: Python while Loops: Repeating Tasks Conditionally",
      "description": "In this quiz, you’ll test your understanding of Python while Loops: Repeating Tasks Conditionally. \nThe while keyword is used to initiate a loop that repeats a block of code while a condition is true. A while loop works by evaluating a condition at the start of each iteration. If the condition is true, then the loop executes. Otherwise, it terminates.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-while-loop/",
      "pubDate": "2025-02-28T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/polars-lazyframe/",
      "title": "How to Work With Polars LazyFrames",
      "description": "A Polars LazyFrame provides an efficient way to handle large datasets through lazy evaluation. Unlike traditional DataFrames, LazyFrames don’t contain data but instead store a set of instructions known as a query plan. Query plans perform operations like predicate and projection pushdown, ensuring only necessary rows and columns are processed. LazyFrames also support the parallel execution of query plans, further enhancing performance.\nBy the end of this tutorial, you’ll understand that:\nA Polars LazyFrame allows efficient data processing by storing query instructions instead of data.\nLazy evaluation in LazyFrames optimizes query plans before data materialization.\nPredicate and projection pushdown minimize unnecessary data processing in LazyFrames.\nYou create a LazyFrame using functions like scan_parquet() or scan_csv().\nSwitching between lazy and eager modes is sometimes necessary for certain operations.\nDive into this tutorial to discover how LazyFrames can transform your data processing tasks, providing both efficiency and flexibility for managing large datasets.\nBefore you start your learning journey, you should already be comfortable with the basics of working with DataFrames. This could be from any previous Polars experience you have, or from using any other DataFrame library, such as pandas.\nIn addition, you may consider using Jupyter Notebook as you work through many of the examples in this tutorial. Alternatively, JupyterLab will enhance your notebook experience, but any Python environment you’re comfortable with will be fine.\nTo get started, you’ll need some data. For the main part of this tutorial, you’ll use the rides.parquet file included in the downloadable materials. You can download this by clicking the link below:\nGet Your Code: Click here to download the free sample code  that shows you how work with Polars LazyFrames.\nThe rides.parquet file is a doctored version of the taxi ride data freely available on the New York City Taxi and Limousine Commission (TLC) website. The dataset contains edited information about New York taxi cab rides from July 2024. Before you go any further, you’ll need to download the file and place it in your project folder.\nNote: The Parquet format is a format for storing large volumes of data efficiently. Parquet files use compression to minimize storage space. They also maintain metadata about each column allowing columns to be searched efficiently, often in parallel, and without the need to read the entire file. Because this metadata is useful to LazyFrames when they need to investigate a file’s content, Parquet is an excellent format for LazyFrames to use.\nThe table below shows details of the rides.parquet file’s columns, along with their Polars data types. The text in parentheses beside each data type shows how these types are annotated in a DataFrame header when Polars displays its results:\nColumn Name\nPolars Data Type\nDescription\n\n\n\n\npick_up\nString (str)\nPick-up borough\n\n\ndrop_off\nString (str)\nDrop-off borough\n\n\npassengers\nInt32 (i32)\nNumber of passengers\n\n\ndistance\nInt32 (i32)\nTrip distance (miles)\n\n\nfare\nInt32 (i32)\nTotal fare ($)\n\n\n\n\nAs a starting point, you’ll create a LazyFrame and take a first look at its data. To use Polars, you first need to install the Polars library into your Python environment. You might also like to install Matplotlib as well.  You’ll use this to view the inner workings of a LazyFrame graphically later on. To install both from a command prompt you use:\nWindows\n  \nLinux + macOS\n  \nIn a Windows environment use:\nWindows PowerShell\n    \n    \n\n      \n    \nPS> python -m pip install polars matplotlib\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nBoth libraries will install.\nIn a Linux or macOS environment use:\nShell\n    \n    \n\n      \n    \n$ python -m pip install polars matplotlib\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nBoth libraries will install.\nIn a Jupyter Notebook, the command is !python -m pip install polars matplotlib.\nYou can then begin to use the Polars library and all of its cool features. Here’s what your data looks like, and here’s how to create your first LazyFrame:\nPython\n    \n    \n\n      \n    \n>>> import polars as pl\n\n>>> rides = pl.scan_parquet(\"rides.parquet\")\n\n>>> rides.collect()\nshape: (3_076_903, 5)\n┌───────────┬───────────┬────────────┬──────────┬──────┐\n│ pick_up   ┆ drop_off  ┆ passengers ┆ distance ┆ fare │\n│ ---       ┆ ---       ┆ ---        ┆ ---      ┆ ---  │\n│ str       ┆ str       ┆ i32        ┆ i32      ┆ i32  │\n╞═══════════╪═══════════╪════════════╪══════════╪══════╡\n│ Manhattan ┆ Manhattan ┆ 1          ┆ 3        ┆ 24   │\n│ Queens    ┆ Manhattan ┆ 1          ┆ 19       ┆ 75   │\n│ Manhattan ┆ Queens    ┆ 1          ┆ 1        ┆ 16   │\n│ Queens    ┆ Manhattan ┆ 0          ┆ 9        ┆ 60   │\n│ Queens    ┆ Manhattan ┆ 1          ┆ 17       ┆ 90   │\n│ …         ┆ …         ┆ …          ┆ …        ┆ …    │\n│ Manhattan ┆ Manhattan ┆ null       ┆ 5        ┆ 27   │\n│ Manhattan ┆ Manhattan ┆ null       ┆ 4        ┆ 26   │\n│ Queens    ┆ Brooklyn  ┆ null       ┆ 4        ┆ 26   │\n│ Manhattan ┆ Manhattan ┆ null       ┆ 3        ┆ 24   │\n│ Manhattan ┆ Manhattan ┆ null       ┆ 8        ┆ 35   │\n└───────────┴───────────┴────────────┴──────────┴──────┘\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nFirst of all, you import the Polars library using the conventional pl alias. You then use the scan_parquet() function to read rides.parquet. This makes your LazyFrame aware of the data file’s content. A LazyFrame doesn’t contain data but instead contains a set of instructions detailing what processing is to be carried out. To access the data, you need to materialize your LazyFrame by calling its .collect() method. This creates a DataFrame and reads the data.\nIn this example, .collect() shows there are 3,076,903 rows and five columns of data, as indicated by its shape.\nUsing LazyFrames may seem like a strange way of working given that you have to materialize them into DataFrames to view the data. You might wonder why not just stick with DataFrames instead. As you’ll see later, despite their name, LazyFrames offer an extremely efficient way to work with data. With their lazy evaluation capabilities, LazyFrames should be your preferred way to work with data in Polars whenever possible.\nNext, you’ll learn the main ways you can create LazyFrames.\n Take the Quiz: Test your knowledge with our interactive “How to Work With Polars LazyFrames” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nHow to Work With Polars LazyFrames \n      \nThis quiz will challenge your knowledge of working with Polars LazyFrames. You won't find all the answers in the tutorial, so you'll need to do some extra investigating. By finding all the answers, you're sure to learn some interesting things along the way.\nHow to Create a Polars LazyFrame\nYou can create LazyFrames in three main ways:\nRead the full article at https://realpython.com/polars-lazyframe/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/polars-lazyframe/",
      "pubDate": "2025-02-26T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/polars-lazyframe/",
      "title": "Quiz: How to Work With Polars LazyFrames",
      "description": "In this quiz, you’ll test your understanding of the techniques covered in\nHow to Work With Polars LazyFrames.\nBy working through the questions, you’ll review your understanding of why LazyFrames are an efficient and preferred way of working in Polars.\nYou’ll need to do some research outside of the tutorial to answer all the questions, so let this challenge take you on a learning journey.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/polars-lazyframe/",
      "pubDate": "2025-02-26T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/single-double-underscore-naming-conventions/",
      "title": "Single and Double Underscore Naming Conventions in Python",
      "description": "Python has a few important naming conventions that are based on using either a single or double underscore character (_). These conventions allow you to differentiate between public and non-public names in APIs, write safe classes for subclassing purposes, avoid name clashes, and more.\nFollowing and respecting these conventions allows you to write code that looks Pythonic and consistent in the eyes of other Python developers. This skill is especially useful when you’re writing code that’s intended for other developers to work with.\nIn this video course, you’ll:\nLearn about Python naming conventions that rely on using underscores (_)\nDifferentiate public and non-public names by using a single leading underscore\nUse double leading underscores to leverage name mangling in Python classes\nExplore other common uses of underscores in Python names\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/single-double-underscore-naming-conventions/",
      "pubDate": "2025-02-25T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-sort/",
      "title": "How to Use sorted() and .sort() in Python",
      "description": "Sorting in Python is a fundamental task that you can accomplish using sorted() and .sort(). The sorted() function returns a new sorted list from the elements of any iterable, without modifying the original iterable. On the other hand, the .sort() method modifies a list in place and doesn’t return a value. Both methods support customization through optional keyword arguments like key and reverse.\nBy the end of this tutorial, you’ll understand that:\nYou can sort any iterable with the sorted() function.\nThe sorted() function returns a new sorted list.\nThe .sort() method sorts the list in place.\nYou sort items in descending order by setting the reverse argument to True.\nThe key argument accepts a function to customize the sort order.\nIn this tutorial, you’ll learn how to sort various types of data in different data structures, customize the order, and work with two different ways of sorting in Python. You’ll need a basic understanding of lists and tuples as well as sets. These are the data structures you’ll be using to perform some basic operations.\nGet Your Cheat Sheet: Click here to download a free cheat sheet that summarizes how to use sorted() and .sort() in Python.\n Take the Quiz: Test your knowledge with our interactive “How to Use sorted() and .sort() in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nHow to Use sorted() and .sort() in Python \n      \nIn this quiz, you'll test your understanding of sorting in Python using sorted() and .sort(). You'll revisit how to sort various types of data in different data structures, customize the order, and work with two different ways of sorting in Python.\nOrdering Values With sorted()\nIn Python, you can sort iterables with the sorted() built-in function. To get started, you’ll work with iterables that contain only one data type.\nSorting Numbers\nYou can use sorted() to sort a list in Python. In this example, a list of integers is defined, and then sorted() is called with the numbers variable as the argument:\nPython\n    \n    \n\n      \n    \n>>> numbers = [6, 9, 3, 1]\n>>> sorted(numbers)\n[1, 3, 6, 9]\n>>> numbers\n[6, 9, 3, 1]\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nThe output from this code is a new, sorted list. When the original variable is printed, the initial values are unchanged.\nThis example shows four important characteristics of sorted(): \nYou don’t have to define the sorted() function. It’s a built-in function that’s available in any standard installation of Python.\nYou’re ordering the values in numbers from smallest to largest when you call sorted(numbers). When you pass no additional arguments or parameters,  sorted() orders the values in numbers in ascending order.\nYou don’t change the original numbers variable because sorted() provides sorted output and doesn’t update the original value in place. \nYou get an ordered list as a return value when you call sorted(). \nThese points mean that sorted() can be used on a list, and the output can immediately be assigned to a variable:  \nPython\n    \n    \n\n      \n    \n>>> numbers = [6, 9, 3, 1]\n>>> numbers_sorted = sorted(numbers)\n>>> numbers_sorted\n[1, 3, 6, 9]\n>>> numbers\n[6, 9, 3, 1]\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this example, a new variable called numbers_sorted now stores the output of the sorted() function.\nYou can confirm all of these observations by calling help() on sorted():\nPython\n    \n    \n\n      \n    \n>>> help(sorted)\nHelp on built-in function sorted in module builtins:\n\nsorted(iterable, /, *, key=None, reverse=False)\n    Return a new list containing all items from the iterable in ascending order.\n\n    A custom key function can be supplied to customize the sort order, and the\n    reverse flag can be set to request the result in descending order.\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nYou’ll cover the optional arguments key and reverse later in the tutorial.\nThe first parameter of sorted() is an iterable. That means that you can use sorted() on tuples and sets very similarly:\nPython\n    \n    \n\n      \n    \n>>> numbers_tuple = (6, 9, 3, 1)\n>>> sorted(numbers_tuple)\n[1, 3, 6, 9]\n\n>>> numbers_set = {5, 10, 1, 0}\n>>> sorted(numbers_set)\n[0, 1, 5, 10]\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nNotice how even though the input was a set and a tuple, the output is a list because sorted() returns a new list by definition. The returned object can be cast to a new type if it needs to match the input type. Be careful if attempting to cast the resulting list back to a set, as a set by definition is unordered:\nPython\n    \n    \n\n      \n    \n>>> numbers_tuple = (6, 9, 3, 1)\n>>> numbers_set = {5, 10, 1, 0}\n>>> numbers_tuple_sorted = sorted(numbers_tuple)\n>>> numbers_set_sorted = sorted(numbers_set)\n>>> numbers_tuple_sorted\n[1, 3, 6, 9]\n>>> numbers_set_sorted\n[0, 1, 5, 10]\n>>> tuple(numbers_tuple_sorted)\n(1, 3, 6, 9)\n>>> set(numbers_set_sorted)\n{0, 1, 10, 5}\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nWhen you cast the numbers_set_sorted value to a set, it’s unordered, as expected. If you’re curious about how sets work in Python, then you can check out the tutorial Sets in Python.\nRead the full article at https://realpython.com/python-sort/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-sort/",
      "pubDate": "2025-02-24T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-sort/",
      "title": "Quiz: How to Use sorted() and .sort() in Python",
      "description": "In this quiz, you’ll test your understanding of\nsorting in Python.\nBy working through this quiz, you’ll revisit how to sort various types of data in different data structures, customize the order, and work with two different ways of sorting in Python.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-sort/",
      "pubDate": "2025-02-24T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/240/",
      "title": "The Real Python Podcast – Episode #240: Telling Effective Stories With Your Python Visualizations",
      "description": "How do you make compelling visualizations that best convey the story of your data? What methods can you employ within popular Python tools to improve your plots and graphs? This week on the show, Matt Harrison returns to discuss his new book \"Effective Visualization: Exploiting Matplotlib & Pandas.\"\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/240/",
      "pubDate": "2025-02-21T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-pyproject-toml/",
      "title": "How to Manage Python Projects With pyproject.toml",
      "description": "The pyproject.toml file simplifies Python project configuration by unifying package setup, managing dependencies, and streamlining builds. In this tutorial, you’ll learn how it can improve your day-to-day Python setup by exploring its key use cases, like configuring your build system, installing packages locally, handling dependencies, and publishing to PyPI.\nBy the end of this tutorial, you’ll understand that:\npyproject.toml is a key component for defining a Python project’s build system, specifying requirements and the build backend.\nDependencies and optional dependencies can be managed directly within the pyproject.toml file or combined with the traditional requirements.txt.\nScripts for command-line execution are defined in the [project.scripts] section, allowing you to automate common tasks.\nDynamic metadata in pyproject.toml enables flexible project configuration, with attributes like version being resolved at build time.\nThe Python packaging ecosystem includes various tools that leverage pyproject.toml for project management, enhancing collaboration, flexibility, and configurability.\nTo get the most out of this tutorial, you should be familiar with the basics of Python. You should know how to import modules and install packages with pip. You should also be able to navigate the terminal and understand how to create virtual environments.\nThe pyproject.toml package configuration file is the relatively new (circa 2016) standard in the Python ecosystem, intended to unify package configuration. It’s also supported by many major tools for managing your Python projects. Some of the project management tools that support the pyproject.toml file are pip, Setuptools, Poetry, Flit, pip-tools, Hatch, PDM, and uv.\nThe pyproject.toml file is a configuration file written in the TOML syntax. For many Python project management needs, a minimal pyproject.toml file doesn’t have to contain a lot of information:\nTOML\n    pyproject.toml\n    \n[project]\nname = \"a-sample-project\"\nversion = \"1.0.0\"\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nDifferent tools have different requirements, but the name and version of your project are officially the only required fields in the [project] table. Typically, you’ll want to include more fields, but if you only want to include a minimal pyproject.toml file, then that’s all you’ll need to get started. Just include this file at the root of your project.\nTo understand more about why using a pyproject.toml file may be useful, you’ll explore a sample CLI application to show you how the pyproject.toml file fits into a standard project workflow.\nGet Your Code: Click here to download the free sample code  you’ll use to learn how to manage Python projects with pyproject.toml.\nSetting Up a Python Project With pyproject.toml\nThe example project you’ll work with in this tutorial is inspired by the classic cowsay program. The example project is called snakesay and—once installed—you can run it with the ssay command:\nShell\n    \n    \n\n      \n    \n$ ssay Hello, World!\n\n _______________\n( Hello, World! )\n ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n  \\\n   \\    ___\n    \\  (o o)\n        \\_/ \\\n         λ \\ \\\n           _\\ \\_\n          (_____)_\n         (________)=Oo°\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nAs you can see, the program takes a string argument and echoes it back with a bit of ASCII art.\nThe structure of the example project follows a popular pattern for Python projects:\nsnakesay-project/    ← The project root\n│\n├── snakesay/        ← The main module of this project\n│   ├── __init__.py\n│   ├── __main__.py  ← The entry point to snakesay\n│   └── snake.py     ← The core of the program\n│\n├── .gitignore\n├── LICENSE\n├── pyproject.toml   ← What this tutorial is about\n└── README.md\n\n\nThe directory snakesay-project is the root location of your project. The main package, where most of the code goes, is the snakesay directory.\nNote: A popular and often recommended project layout is the src layout:\nsnakesay-project/\n│\n├── src/\n│   └── snakesay/\n│       ├── __init__.py\n│       ├── __main__.py\n│       └── snake.py\n...\n\n\nThis layout has two key advantages: it makes the location of the source code more explicit and helps avoid some of the issues that can arise with more complex configurations, especially with testing.\nAt the root level of the project, you’ve got the star of this tutorial, the pyproject.toml file. In this project, the pyproject.toml file currently contains the following content:\nTOML\n    pyproject.toml\n    \n[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"snakesay\"\nversion = \"1.0.0\"\n\n[project.scripts]\nssay = \"snakesay.__main__:main\"\n\n[tool.setuptools.packages.find]\nwhere = [\".\"]\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nAs the tutorial progresses, you’ll examine what all this means in more detail. You’ll also expand this pyproject.toml to include more tables and fields. As it stands, this pyproject.toml file includes:\nThe [build-system] table: Specifies what’s needed to build the project. The requires key lists the required packages, and the build-backend key defines the module used for the build process.\nThe [project] table: Contains essential project metadata and has plenty of optional fields, some of which you’ll explore later in this tutorial.\nThe [project.scripts] table: Allows you to define one or several executable commands to be able to call your application from the command line. In this case, it’s ssay, but it can be anything you like.\nThe [tools.setuptools.packages.find] table: Tells your build-system, Setuptools, where to find packages in your project. In this case, it’s just the root directory.\nWith this pyproject.toml file, you’ve already defined all the configuration you need to build and run your project.\nThe [tools.setuptools.packages.find] table isn’t required since the value of [\".\"] is the default. Even though it’s the default, sometimes Setuptools can’t find other modules in the project root, and explicitly setting the where key can help with this.\nSetuptools has various defaults for package discovery, which include the current project layout and the src layout.\nRead the full article at https://realpython.com/python-pyproject-toml/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-pyproject-toml/",
      "pubDate": "2025-02-19T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/concatenating-strings-efficiently/",
      "title": "Concatenating Strings in Python Efficiently",
      "description": "Python string concatenation is a fundamental operation that combines multiple strings into a single string. In Python, you can concatenate strings using the + operator or append them with +=. For more efficient concatenation, especially when working with lists of strings, the .join() method is recommended. Other techniques include using StringIO for large datasets and the print() function for quick screen output.\nBy the end of this video course, you’ll understand that you can:\nConcatenate strings in Python using the + and += operators.\nUse += to append a string to an existing string.\nUse the .join() method to combine strings in a list in Python.\nHandle a stream of strings efficiently by using StringIO as a container with a file-like interface.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/concatenating-strings-efficiently/",
      "pubDate": "2025-02-18T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-news-february-2025/",
      "title": "Python News Roundup: February 2025",
      "description": "The new year has brought a flurry of activity to the Python community. New bugfix releases of Python 3.12 and 3.13 show that the developers seemingly never sleep. A new type of interpreter is slated for the upcoming Python 3.14 as part of ongoing efforts to improve Python’s performance.\nPoetry takes a giant leap toward compatibilty with other project management tools with the release of version 2. If you’re interested in challenging yourself with some programming puzzles, check out the new season of Coding Quest.\nTime to jump in! Enjoy this tour of what’s happening in the world of Python!\nPoetry Version 2 Adds Compatibility\nPoetry is a trusted and powerful project and dependency manager for Python. Initially created by Sébastien Eustace in 2018, it reached its Version 1 milestone in 2019. Since then, it has grown to be one of the most commonly used tools for managing Python projects.\nOn January 5, 2025, the Poetry team announced the release of Poetry 2.0.0. This major release comes with many updates. One of the most requested changes is compatibility with PEP 621, which describes how to specify project metadata in pyproject.toml.\nMost of the common tools for project management, including setuptools, uv, Hatch, Flit, and PDM, use pyproject.toml and the project table in a consistent way, as defined in PEP 621. With Poetry on board as well, you can more simply migrate your project from one tool to another.\nThis improved compatibility with the rest of the Python eco-system comes with a price. There are a few breaking changes in Poetry 2 compared to earlier versions. If you’re already using Poetry, you should take care when updating to the latest version.\nThe changelog describes all changes, and you can read the documentation for advice on how to migrate your existing projects to the new style of configuration. \nThe Python Team Releases Bugfix Versions for 3.12 and 3.13\nRead the full article at https://realpython.com/python-news-february-2025/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-news-february-2025/",
      "pubDate": "2025-02-17T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/239/",
      "title": "The Real Python Podcast – Episode #239: Behavior-Driven vs Test-Driven Development & Using Regex in Python",
      "description": "What is behavior-driven development, and how does it work alongside test-driven development? How do you communicate requirements between teams in an organization? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/239/",
      "pubDate": "2025-02-14T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-keywords/",
      "title": "Python Keywords: An Introduction",
      "description": "Python keywords are reserved words with specific functions and restrictions in the language. Currently, Python has thirty-five keywords and four soft keywords. These keywords are always available in Python, which means you don’t need to import them. Understanding how to use them correctly is fundamental for building Python programs.\nBy the end of this tutorial, you’ll understand that:\nThere are 35 keywords and four soft keywords in Python.\nYou can get a list of all keywords using keyword.kwlist from the keyword module.\nSoft keywords in Python act as keywords only in specific contexts.\nprint and exec are keywords that have been deprecated and turned into functions in Python 3.\nIn this article, you’ll find a basic introduction to all Python keywords and soft keywords along with other resources that will be helpful for learning more about each keyword.\nGet Your Cheat Sheet: Click here to download a free cheat sheet that summarizes the main keywords in Python.\n Take the Quiz: Test your knowledge with our interactive “Python Keywords: An Introduction” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nPython Keywords: An Introduction \n      \nIn this quiz, you'll test your understanding of Python keywords and soft keywords. These reserved words have specific functions and restrictions in Python, and understanding how to use them correctly is fundamental for building Python programs.\nPython Keywords\nPython keywords are special reserved words that have specific meanings and purposes and can’t be used for anything but those specific purposes. These keywords are always available—you’ll never have to import them into your code.\nPython keywords are different from Python’s built-in functions and types. The built-in functions and types are also always available, but they aren’t as restrictive as the keywords in their usage. \nAn example of something you can’t do with Python keywords is assign something to them. If you try, then you’ll get a SyntaxError. You won’t get a SyntaxError if you try to assign something to a built-in function or type, but it still isn’t a good idea. For a more in-depth explanation of ways keywords can be misused, check out Invalid Syntax in Python: Common Reasons for SyntaxError.\nThere are thirty-five keywords in Python. Here’s a list of them, each linked to its relevant section in this tutorial:\nFalse\nawait\nelse\nimport\npass\n\n\nNone\nbreak\nexcept\nin\nraise\n\n\nTrue\nclass\nfinally\nis\nreturn\n\n\nand\ncontinue\nfor\nlambda\ntry\n\n\nas\ndef\nfrom\nnonlocal\nwhile\n\n\nassert\ndel\nglobal\nnot\nwith\n\n\nasync\nelif\nif\nor\nyield\n\n\n\n\nTwo keywords have additional uses beyond their initial use cases. The else keyword is also used with loops and with try and except in addition to in conditional statements. The as keyword is most commonly used in import statements, but also used with the with keyword.\nThe list of Python keywords and soft keywords has changed over time. For example, the await and async keywords weren’t added until Python 3.7. Also, both print and exec were keywords in Python 2.7 but were turned into built-in functions in Python 3 and no longer appear in the keywords list.\nPython Soft Keywords\nAs mentioned above, you’ll get an error if you try to assign something to a Python keyword. Soft keywords, on the other hand, aren’t that strict. They syntactically act as keywords only in certain conditions.\nThis new capability was made possible thanks to the introduction of the PEG parser in Python 3.9, which changed how the interpreter reads the source code.\nLeveraging the PEG parser allowed for the introduction of structural pattern matching in Python. In order to use intuitive syntax, the authors picked match, case, and _ for the pattern matching statements. Notably, match and case are widely used for this purpose in many other programming languages.\nTo prevent conflicts with existing Python code that already used match, case, and _ as variable or function names, Python developers decided to introduce the concept of soft keywords.\nCurrently, there are four soft keywords in Python:\nmatch\ncase\n_\ntype\n\n\n\n\nYou can use the links above to jump to the soft keywords you’d like to read about, or you can continue reading for a guided tour.\nValue Keywords: True, False, None\nThere are three Python keywords that are used as values. These values are singleton values that can be used over and over again and always reference the exact same object. You’ll most likely see and use these values a lot.\nThere are a few terms used in the sections below that may be new to you. They’re defined here, and you should be aware of their meaning before proceeding:\nRead the full article at https://realpython.com/python-keywords/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-keywords/",
      "pubDate": "2025-02-12T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-keywords/",
      "title": "Quiz: Python Keywords: An Introduction",
      "description": "In this quiz, you’ll test your understanding of Python Keywords.\nPython keywords are reserved words with specific functions and restrictions in the language. These keywords are always available in Python, which means you don’t need to import them. Understanding how to use them correctly is fundamental for building Python programs.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-keywords/",
      "pubDate": "2025-02-12T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/build-command-line-todo-app-typer/",
      "title": "Building a Python Command-Line To-Do App With Typer",
      "description": "Building an application to manage your to-do list can be an interesting project when you’re learning a new programming language or trying to take your skills to the next level. In this video course, you’ll build a functional to-do application for the command line using Python and Typer, which is a relatively young library for creating powerful command-line interface (CLI) applications in almost no time.\nWith a project like this, you’ll apply a wide set of core programming skills while building a real-world application with real features and requirements.\nIn this video course, you’ll learn how to:\nBuild a functional to-do application with a Typer CLI in Python\nUse Typer to add commands, arguments, and options to your to-do app\nTest your Python to-do application with Typer’s CliRunner and pytest\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/build-command-line-todo-app-typer/",
      "pubDate": "2025-02-11T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-join-string/",
      "title": "How to Join Strings in Python",
      "description": "Python’s built-in string method .join() lets you combine string elements from an iterable into a single string, using a separator that you specify. You call .join() on the separator, passing the iterable of strings to join.\nBy the end of this tutorial, you’ll understand that:\nYou use .join() in Python to combine string elements with a specified separator.\nA separator is the piece of text you want inserted between each substring.\nTo join list elements, you call .join() on a separator string, passing the list as the argument.\n.join() inserts the separator between each list element to form a single string.\nThe .join() method returns a new string that is the concatenation of the elements in the iterable, separated by the specified string.\nFor smaller string concatenation tasks, you can use the concatenation operator (+) or f-strings instead of .join().\nPython’s built-in str.join() method gives you a quick and reliable way to combine multiple strings into a single string. Whether you need to format output or assemble data for storage, .join() provides a clean and efficient approach for joining strings from an iterable.\nIn the upcoming sections, you’ll learn the basic usage of .join() to concatenate strings effectively. You’ll then apply that knowledge to real-world scenarios, from building CSV files to constructing custom log outputs. You’ll also discover some surprising pitfalls and learn how to avoid them.\nGet Your Code: Click here to download the free sample code  that shows you how to join strings in Python.\n Take the Quiz: Test your knowledge with our interactive “How to Join Strings in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nHow to Join Strings in Python \n      \nTest your understanding of Python's .join() string method for combining strings, handling edge cases, and optimizing performance.\nHow to Join Strings in Python Using .join()\nTo use the string method .join(), you call .join() on a separator string and pass an iterable of other strings as the argument. The method returns a single string, where it has inserted the separator string between each element of the iterable:\nPython\n    \n    \n\n      \n    \n>>> words = [\"Time\", \"flies\", \"like\", \"an\", \"arrow!\"]\n>>> \" \".join(words)\n'Time flies like an arrow!'\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this example, you joined a list of words into one sentence, separated by spaces.\nAt first glance, this usage might look a little backward. In many other string operations, you call the method on the main string that you want to manipulate. However, with .join(), you call the method on the separator string, then pass the iterable of strings that you want to combine:\nPython\n    \n    \n\n      \n    \n>>> separator = \" \"\n>>> separator.join(words)\n'Time flies like an arrow!'\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nThis example achieves the same result as the earlier one but splits the process into two steps. Defining separator separately makes the code more readable and avoids the potentially odd-looking syntax of calling .join() directly on a short string literal.\nNote: Remember that .join() is a string method, which means that you’ll need to call it on a single string object. Keeping that in mind may help you remember why you need to call it on the separator string.\nYou rarely see code that’s written in multiple steps where you assign the separator string to a variable, like you did in the example above.\nIn typical usage, you call .join() directly on the separator string, all in one line. This approach is more concise and highlights that any valid string can be your separator, whether it’s whitespace, a dash, or a multicharacter substring.\nJoin With an Empty String\nWhat if you don’t want any separator at all, but just want to concatenate the items? One valid approach is to use an empty string (\"\") as the separator:\nPython\n    \n    \n\n      \n    \n>>> letters = [\"A\", \"B\", \"C\", \"D\"]\n>>> \"\".join(letters)\n'ABCD'\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nThis code snippet concatenates the letters in the list, forming a single string \"ABCD\". Using an empty string as the separator is a great way to assemble strings without a delimiter between them.\nCombine Strings of Characters\nSince .join() can take any iterable of strings—not just lists—you can even pass a string as an argument. Because strings are iterable, Python iterates over each character in that string, considering each character as a separate element:\nPython\n    \n    \n\n      \n    \n>>> characters = \"ABCD\"\n>>> \",\".join(characters)\n'A,B,C,D'\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nBy calling .join() on \",\" and passing the string characters, you effectively place a comma between every single character in \"ABCD\". This might not always be what you intend, but it’s a neat trick to keep in mind if you ever need to treat each character as a separate element.\nRead the full article at https://realpython.com/python-join-string/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-join-string/",
      "pubDate": "2025-02-10T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/238/",
      "title": "The Real Python Podcast – Episode #238: Charlie Marsh: Accelerating Python Tooling With Ruff and uv",
      "description": "Are you looking for fast tools to lint your code and manage your projects? How is the Rust programming language being used to speed up Python tools? This week on the show, we speak with Charlie Marsh about his company, Astral, and their tools, uv and Ruff.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/238/",
      "pubDate": "2025-02-07T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-for-loop/",
      "title": "Quiz: Python \"for\" Loops: The Pythonic Way",
      "description": "In this quiz, you’ll test your understanding of Python’s for loop.\nBy working through this quiz, you’ll revisit how to iterate over items in a data collection, how to use range() for a predefined number of iterations, and how to use enumerate() for index-based iteration.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-for-loop/",
      "pubDate": "2025-02-06T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-join-string/",
      "title": "Quiz: How to Join Strings in Python",
      "description": "In this quiz, you’ll test your understanding of How to Join Strings in Python.\nBy working through this quiz, you’ll review how to use .join() to combine strings with a specified separator and handle non-string data in iterables. You’ll also revisit how .join() compares to other concatenation methods and how it’s optimized in CPython.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-join-string/",
      "pubDate": "2025-02-06T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-split-string/",
      "title": "How to Split a String in Python",
      "description": "Python’s .split() method lets you divide a string into a list of substrings based on a specified delimiter. By default, .split() separates at whitespace, including spaces, tabs, and newlines. You can customize .split() to work with specific delimiters using the sep parameter, and control the amount of splits with maxsplit.\nBy the end of this tutorial, you’ll understand that:\nYou split a string by spaces in Python using .split() without arguments.\nPython’s .split() method can split on custom delimiters when you pass a character or string as an argument.\nYou limit splits using maxsplit to control the number of substrings Python extracts.\n.splitlines() splits multiline strings into individual lines, excluding or including line breaks with the keepends parameter.\nre.split() uses regular expressions for splitting strings based on complex patterns.\nExploring these methods will level up your text-processing capabilities and enable you to confidently tackle real-world data parsing challenges.\nGet Your Code: Click here to download the free sample code that shows you how to split strings in Python.\n Take the Quiz: Test your knowledge with our interactive “How to Split a String in Python” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nHow to Split a String in Python \n      \nIn this quiz, you'll test your understanding of Python's .split() method. This method is useful for text-processing and data parsing tasks, allowing you to divide a string into a list of substrings based on a specified delimiter.\nHow to Split a String in Python Using .split()\nThe .split() method in Python is a versatile tool that allows you to divide a string into a list of substrings based on a specified delimiter. By default, .split() separates a string at each occurrence of whitespace, which includes spaces, tabs, and newlines. This makes it particularly handy when dealing with plain text where words are separated by spaces:\nPython\n    \n    \n\n      \n    \n>>> sentence = \"Python is a versatile language.\"\n>>> sentence.split()\n['Python', 'is', 'a', 'versatile', 'language.']\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nAs you can see, .split() divides the sentence into individual words, removing the spaces in the process. It’s important to note that .split() also strips newlines by default, which might not be immediately obvious:\nPython\n    \n    \n\n      \n    \n>>> text = \"\"\"Line one\n... Line two\n... Line three\"\"\"\n\n>>> text.split()\n['Line', 'one', 'Line', 'two', 'Line', 'three']\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nThe .split() method treats the newline characters as whitespace, and splits the text into individual words rather than lines. This is a crucial point to remember when working with multiline strings.\nThe simplicity of .split() makes it a powerful tool for string manipulation. Whether you’re processing text files or parsing user input, using .split() can streamline your workflow.\nWhen you’re faced with the task of cleaning up messy text, you may want to pair .split() with .strip(). You can learn more about using str.strip().split() by expanding the collapsible section below:\nUsing str.strip().split()Show/Hide\n  \nYou may encounter code that uses .split() in combination with another string method, .strip():\nPython\n    \n    \n\n      \n    \n>>> text = \"    Hello   world  \"\n>>> text.strip().split()\n['Hello', 'world']\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this example, you’re dealing with text that contains whitespace characters at the beginning and end of text. You may see results like this when working with data that you received through web scraping, copy-paste artifacts from PDFs, or even regular user input.\nCombining .strip() and .split() is a common and straightforward way to break potentially messy text into manageable tokens.\nThe idea is that you first remove superfluous whitespace characters from the beginning and end of the string using .strip(). This operation returns a new string object without that whitespace. You then chain .split() to this cleaned output, allowing it to break the text into elements—in this case, individual words.\nIf you’re only dealing with messy whitespace, however, then you don’t need to use .strip() to get to a clean result:\nPython\n    \n    \n\n      \n    \n>>> text = \"    Hello   world  \"\n>>> text.split()\n['Hello', 'world']\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nBecause .split() splits on any whitespace and ignores extra leading and trailing whitespace, the result is the same as when you first explicitly remove leading and trailing whitespace with .strip().\nNevertheless, there may be advantages to adding .strip() into the mix:\nExplicitness: You clearly communicate to other developers that you intend to apply data cleaning—and readability counts!\nFuture-proofing: You may later need to update your code to split on a different delimiter, in which case .split() won’t remove extra whitespace automatically. A well-designed additional step of explicitly removing whitespace with .strip() can prevent surprises.\nIf you’re only splitting on whitespace, then you likely won’t need to use str.strip().split(). However, due to developer habits and a preference for explicitness, you may still come across this combination of string methods in the wild.\nWhen you use .split(), it returns a list of substrings. This means that you can iterate over the result, access individual elements using indexing, or unpack the iterable into separate variables.\nFor example, when you’re dealing with user input, you might want to extract specific pieces of information:\nPython\n    \n    \n\n      \n    \n>>> user_input = \"Deborah Lopez 30\"\n>>> user_data = user_input.split()\n>>> user_data\n['Deborah', 'Lopez', '30']\n\n>>> name, surname, age = user_data\n>>> print(f\"Welcome {name}! You're {age} years old.\")\nWelcome Deborah! You're 30 years old.\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this code snippet, you take a string containing a name, surname, and age, and split it into a list of three separate strings. Then, you unpack the list into three descriptive variables. Finally, you use an f-string to format the output.\nNote: Extracting data pieces like this is useful when you’re dealing with structured data where you know the position of each element beforehand, and you can rely on consistent use of whitespace.\nIn this section, you’ve learned how to use Python’s .split() method to divide strings into smaller parts based on whitespace. This method is invaluable when working with plain text data, allowing you to extract and manipulate information. By understanding the default behavior of .split(), including its treatment of newlines, you’ll be well-equipped to handle a variety of string manipulation tasks in your Python projects.\nIn the next section, you’ll explore how to customize the behavior of .split() by specifying different delimiters, enabling you to tackle more complex string splitting scenarios.\nSplit With Different Delimiters Using sep\nBy default, .split() uses any whitespace as a delimiter to separate a string into a list of substrings. However, many real-world scenarios require splitting strings using other delimiters. This is where the sep parameter comes into play.\nImagine that you’re parsing data from a CSV (comma-separated values) file. CSV files are a popular format for storing tabular data, where each line represents a row and each value within a line is separated by a comma.\nRead the full article at https://realpython.com/python-split-string/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-split-string/",
      "pubDate": "2025-02-05T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/numpy-techniques-practical-examples/",
      "title": "NumPy Techniques and Practical Examples",
      "description": "The NumPy library is a Python library used for scientific computing. It provides you with a multidimensional array object for storing and analyzing data in a wide variety of ways. In this video course, you’ll see examples of some features NumPy provides that aren’t always highlighted in other tutorials. \nIn this video course, you’ll learn how to:\nCreate multidimensional arrays from data stored in files\nIdentify and remove duplicate data from a NumPy array\nUse structured NumPy arrays to reconcile the differences between datasets\nAnalyze and chart specific parts of hierarchical data\nCreate vectorized versions of your own functions\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/numpy-techniques-practical-examples/",
      "pubDate": "2025-02-04T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/python-split-string/",
      "title": "Quiz: How to Split a String in Python",
      "description": "In this quiz, you’ll test your understanding of\nPython’s .split() method.\nPython’s .split() method lets you divide a string into a list of substrings based on a specified delimiter. By default, .split() separates at whitespace, including spaces, tabs, and newlines. You can customize .split() to work with specific delimiters using the sep parameter, and control the amount of splits with maxsplit.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/python-split-string/",
      "pubDate": "2025-02-04T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/python-for-loop/",
      "title": "Python for Loops: The Pythonic Way",
      "description": "Python’s for loop allows you to iterate over the items in a collection, such as lists, tuples, strings, and dictionaries. The for loop syntax declares a loop variable that takes each item from the collection in each iteration. This loop is ideal for repeatedly executing a block of code on each item in the collection. You can also tweak for loops further with features like break, continue, and else.\nBy the end of this tutorial, you’ll understand that:\nPython’s for loop iterates over items in a data collection, allowing you to execute code for each item.\nTo iterate from 0 to 10, you use the for index in range(11): construct.\nTo repeat code a number of times without processing the data of an iterable, use the for _ in range(times): construct.\nTo do index-based iteration, you can use for index, value in enumerate(iterable): to access both index and item.\nIn this tutorial, you’ll gain practical knowledge of using for loops to traverse various collections and learn Pythonic looping techniques. Additionally, you’ll learn how to handle exceptions and how to use asynchronous iterations to make your Python code more robust and efficient.\nGet Your Code: Click here to download the free sample code that shows you how to use for loops in Python.\n Take the Quiz: Test your knowledge with our interactive “Python \"for\" Loops: The Pythonic Way” quiz. You’ll receive a score upon completion to help you track your learning progress:\n\n            \n \n      \nInteractive Quiz\nPython \"for\" Loops: The Pythonic Way \n      \nIn this quiz, you'll test your understanding of Python's for loop. You'll revisit how to iterate over items in a data collection, how to use range() for a predefined number of iterations, and how to use enumerate() for index-based iteration.\nGetting Started With the Python for Loop\nIn programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\nfor loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\nwhile loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition.\nPython has both of these loops and in this tutorial, you’ll learn about for loops. In Python, you’ll generally use for loops when you need to iterate over the items in a data collection. This type of loop lets you traverse different data collections and run a specific group of statements on or with each item in the input collection.\nIn Python, for loops are compound statements with a header and a code block that runs a predefined number of times. The basic syntax of a for loop is shown below:\nPython Syntax\n    \n    \nfor variable in iterable:\n    <body>\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this syntax, variable is the loop variable. In each iteration, this variable takes the value of the current item in iterable, which represents the data collection you need to iterate over. The loop body can consist of one or more statements that must be indented properly.\nHere’s a more detailed breakdown of this syntax:\nfor is the keyword that initiates the loop header.\nvariable is a variable that holds the current item in the input iterable.\nin is a keyword that connects the loop variable with the iterable.\niterable is a data collection that can be iterated over.\n<body> consists of one or more statements to execute in each iteration.\nHere’s a quick example of how you can use a for loop to iterate over a list:\nPython\n    \n    \n\n      \n    \n>>> colors = [\"red\", \"green\", \"blue\", \"yellow\"]\n\n>>> for color in colors:\n...     print(color)\n...\nred\ngreen\nblue\nyellow\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this example, color is the loop variable, while the colors list is the target collection. Each time through the loop, color takes on a successive item from colors. In this loop, the body consists of a call to print() that displays the value on the screen. This loop runs once for each item in the target iterable. The way the code above is written is the Pythonic way to write it.\nHowever, what’s an iterable anyway? In Python, an iterable is an object—often a data collection—that can be iterated over. Common examples of iterables in Python include lists, tuples, strings, dictionaries, and sets, which are all built-in data types. You can also have custom classes that support iteration.\nNote: Python has both iterables and iterators. Iterables support the iterable protocol consisting of the .__iter__() special method. Similarly, iterators support the iterator protocol that’s based on the .__iter__() and .__next__() special methods.\nBoth iterables and iterators can be iterated over. All iterators are iterables, but not all iterables are iterators. Python iterators play a fundamental role in for loops because they drive the iteration process.\nA deeper discussion on iterables and iterators is beyond the scope of this tutorial. However, to learn more about them, check out the Iterators and Iterables in Python: Run Efficient Iterations tutorial.\nYou can also have a loop with multiple loop variables:\nPython\n    \n    \n\n      \n    \n>>> points = [(1, 4), (3, 6), (7, 3)]\n\n>>> for x, y in points:\n...     print(f\"{x = } and {y = }\")\n...\nx = 1 and y = 4\nx = 3 and y = 6\nx = 7 and y = 3\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nIn this loop, you have two loop variables, x and y. Note that to use this syntax, you just need to provide a tuple of loop variables. Also, you can have as many loop variables as you need as long as you have the correct number of items to unpack into them. You’ll also find this pattern useful when iterating over dictionary items or when you need to do parallel iteration.\nSometimes, the input iterable may be empty. In that case, the loop will run its header once but won’t execute its body:\nPython\n    \n    \n\n      \n    \n>>> for item in []:\n...     print(item)\n...\n\n\n    \n    \n    \n      Copied!\n    \n    \n  \nRead the full article at https://realpython.com/python-for-loop/ »\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/python-for-loop/",
      "pubDate": "2025-02-03T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/237/",
      "title": "The Real Python Podcast – Episode #237: Testing Your Python Code Base: Unit vs. Integration",
      "description": "What goes into creating automated tests for your Python code? Should you focus on testing the individual code sections or on how the entire system runs? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/237/",
      "pubDate": "2025-01-31T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/create-scalable-flask-web-app/",
      "title": "Creating a Scalable Flask Web Application From Scratch",
      "description": "Flask is a powerful and flexible micro web framework for Python, ideal for both small and large web projects. It provides a straightforward way to get a web application up and running, with all the features that you need to get started.\nOver the course of this video course, you’ll explore the process of creating a boilerplate for a Flask web project. This boilerplate will serve as a great starting point for any scalable Flask web app that you wish to develop in the future, from basic web pages to complex web applications.\nIn this video course, you’ll learn how to:\nSet up a Flask project\nCreate a \"Hello, World!\" Flask app\nAdd multiple pages with blueprints\nLeverage Jinja templates\nStore static files\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/create-scalable-flask-web-app/",
      "pubDate": "2025-01-28T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/236/",
      "title": "The Real Python Podcast – Episode #236: Simon Willison: Using LLMs for Python Development",
      "description": "What are the current large language model (LLM) tools you can use to develop Python? What prompting techniques and strategies produce better results? This week on the show, we speak with Simon Willison about his LLM research and his exploration of writing Python code with these rapidly evolving tools.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/236/",
      "pubDate": "2025-01-24T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/exploring-tuple-data-type-examples/",
      "title": "Exploring Python's tuple Data Type With Examples",
      "description": "In Python, a tuple is a built-in data type that allows you to create immutable sequences of values. The values or items in a tuple can be of any type. This makes tuples pretty useful in those situations where you need to store heterogeneous data, like that in a database record, for example.\nThrough this tutorial, you’ll dive deep into Python tuples and get a solid understanding of their key features and use cases. This knowledge will allow you to write more efficient and reliable code by taking advantage of tuples.\nIn this video course, you’ll learn how to:\nCreate tuples in Python\nAccess the items in an existing tuple\nUnpack, return, copy, and concatenate tuples\nReverse, sort, and traverse existing tuples\nExplore other features and common gotchas of tuples\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/exploring-tuple-data-type-examples/",
      "pubDate": "2025-01-21T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/quizzes/how-to-deal-with-missing-data-in-polars/",
      "title": "Quiz: How to Deal With Missing Data in Polars",
      "description": "In this quiz, you’ll test your understanding of\nHow to Deal With Missing Data in Polars.\nBy working through the questions, you’ll review your understanding of dealing with null values in Polars and also expand on what you learned in the tutorial.\nYou’ll need to do some research outside of the tutorial to answer all the questions. Embrace this challenge and let it take you on a learning journey.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/quizzes/how-to-deal-with-missing-data-in-polars/",
      "pubDate": "2025-01-21T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/235/",
      "title": "The Real Python Podcast – Episode #235: Principles for Considering Your Python Tooling",
      "description": "What are the principles you should consider when making decisions about which Python tools to use? What anti-patterns get in the way of making the right choices for your team? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/235/",
      "pubDate": "2025-01-17T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/building-dictionary-comprehensions/",
      "title": "Building Dictionary Comprehensions in Python",
      "description": "Dictionary comprehensions are a concise and quick way to create, transform, and filter dictionaries in Python. They can significantly enhance your code’s conciseness and readability compared to using regular for loops to process your dictionaries.\nUnderstanding dictionary comprehensions is crucial for you as a Python developer because they’re a Pythonic tool for dictionary manipulation and can be a valuable addition to your programming toolkit.\nIn this video course, you’ll learn how to:\nCreate dictionaries using dictionary comprehensions\nTransform existing dictionaries with comprehensions\nFilter key-value pairs from dictionaries using conditionals\nDecide when to use dictionary comprehensions\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/building-dictionary-comprehensions/",
      "pubDate": "2025-01-14T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/234/",
      "title": "The Real Python Podcast – Episode #234: Building New Structures for Learning Python",
      "description": "What are the new ways we can teach and share our knowledge about Python? How can we improve the structure of our current offerings and build new educational resources for our audience of Python learners? This week on the show, Real Python core team members Stephen Gruppetta and Martin Breuss join us to discuss enhancements to the site and new ways to learn Python.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/234/",
      "pubDate": "2025-01-10T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/interactive-python/",
      "title": "Ways to Start Interacting With Python",
      "description": "There are multiple ways of interacting with Python, and each can be useful for different scenarios. You can quickly explore functionality in Python’s interactive mode using the built-in Read-Eval-Print Loop (REPL), or you can write larger applications to a script file using an editor or Integrated Development Environment (IDE).\nIn this video course, you’ll learn how to:\nUse Python interactively by typing code directly into the interpreter\nExecute code contained in a script file from the command line\nWork within a Python Integrated Development Environment (IDE)\nAssess additional options, such as Thonny and Python’s IDLE\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/interactive-python/",
      "pubDate": "2025-01-07T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/podcasts/rpp/233/",
      "title": "The Real Python Podcast – Episode #233: PyCoder's Weekly 2024 Top Articles & Missing Gems",
      "description": "PyCoder's Weekly included over 1,500 links to articles, blog posts, tutorials, and projects in 2024. Christopher Trudeau is back on the show this week to help wrap it all up by sharing some highlights and uncovering a few missing gems from the pile.\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/podcasts/rpp/233/",
      "pubDate": "2025-01-03T12:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    },
    {
      "id": "https://realpython.com/courses/django-rest-framework/",
      "title": "Building HTTP APIs With Django REST Framework",
      "description": "REST is a loosely defined protocol for listing, creating, changing, and deleting data on your server over HTTP. The Django REST framework (DRF) is a toolkit built on top of the Django web framework that reduces the amount of code you need to write to create REST HTTP API interfaces.\nIn this course you’ll learn about:\nThe REST protocol\nDRF Serializers and how to use them with Django objects\nUsing Django views and DRF ViewSet classes to create REST end-points\nMultiple flavors of renderers and how to control their output\nSpecifying permissions and limiting who can see what data in your REST API\n[ Improve Your Python With 🐍 Python Tricks 💌 – Get a short & sweet Python Trick delivered to your inbox every couple of days. >> Click here to learn more and see examples ]",
      "link": "https://realpython.com/courses/django-rest-framework/",
      "pubDate": "2024-12-31T14:00:00.000Z",
      "source": "Real Python",
      "sourceUrl": "https://realpython.com",
      "category": "Python"
    }
  ]
}